class ZodError extends Error {
  constructor(issues) {
    super('Validation error');
    this.name = 'ZodError';
    this.issues = issues;
  }
}

const ZodIssueCode = {
  custom: 'custom',
  invalid_type: 'invalid_type',
  invalid_literal: 'invalid_literal',
};

const uuidRegex = /^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i;

class BaseSchema {
  optional() {
    return new OptionalSchema(this);
  }

  nullable() {
    return new NullableSchema(this);
  }

  default(value) {
    return new DefaultSchema(this, value);
  }

  transform(fn) {
    return new TransformSchema(this, fn);
  }
}

class TransformSchema extends BaseSchema {
  constructor(inner, transformer) {
    super();
    this.inner = inner;
    this.transformer = transformer;
  }

  parse(value, path = []) {
    const parsed = this.inner.parse(value, path);
    return this.transformer(parsed, { path });
  }
}

class OptionalSchema extends BaseSchema {
  constructor(inner) {
    super();
    this.inner = inner;
  }

  parse(value, path = []) {
    if (value === undefined) return undefined;
    return this.inner.parse(value, path);
  }
}

class NullableSchema extends BaseSchema {
  constructor(inner) {
    super();
    this.inner = inner;
  }

  parse(value, path = []) {
    if (value === null) return null;
    return this.inner.parse(value, path);
  }
}

class DefaultSchema extends BaseSchema {
  constructor(inner, defaultValue) {
    super();
    this.inner = inner;
    this.defaultValue = defaultValue;
  }

  parse(value, path = []) {
    if (value === undefined) return typeof this.defaultValue === 'function'
      ? this.defaultValue()
      : this.defaultValue;
    return this.inner.parse(value, path);
  }
}

class PreprocessSchema extends BaseSchema {
  constructor(preprocessor, inner) {
    super();
    this.preprocessor = preprocessor;
    this.inner = inner;
  }

  parse(value, path = []) {
    let processed;
    try {
      processed = this.preprocessor(value);
    } catch (error) {
      throw new ZodError([
        {
          path,
          message: error && error.message ? error.message : 'Invalid input',
          code: ZodIssueCode.custom,
        },
      ]);
    }
    return this.inner.parse(processed, path);
  }
}

class AnySchema extends BaseSchema {
  parse(value) {
    return value;
  }
}

class LiteralSchema extends BaseSchema {
  constructor(expected) {
    super();
    this.expected = expected;
  }

  parse(value, path = []) {
    if (value !== this.expected) {
      throw new ZodError([
        {
          path,
          message: `Expected literal ${this.expected}`,
          code: ZodIssueCode.invalid_literal,
        },
      ]);
    }
    return value;
  }
}

class EnumSchema extends BaseSchema {
  constructor(values, options = {}) {
    super();
    this.values = values;
    this.options = options;
  }

  parse(value, path = []) {
    if (typeof value !== 'string' || !this.values.includes(value)) {
      const message =
        (this.options.errorMap && this.options.errorMap().message) ||
        `Invalid enum value. Expected one of ${this.values.join(', ')}`;
      throw new ZodError([
        {
          path,
          message,
          code: ZodIssueCode.invalid_type,
        },
      ]);
    }
    return value;
  }
}

class UnionSchema extends BaseSchema {
  constructor(schemas) {
    super();
    this.schemas = schemas;
  }

  parse(value, path = []) {
    const errors = [];
    for (const schema of this.schemas) {
      try {
        return schema.parse(value, path);
      } catch (error) {
        if (error instanceof ZodError) {
          errors.push(...error.issues);
        } else {
          throw error;
        }
      }
    }
    throw new ZodError(errors.length ? errors : [{ path, message: 'Invalid input', code: ZodIssueCode.custom }]);
  }
}

class StringSchema extends BaseSchema {
  constructor(options = {}) {
    super();
    this.options = options;
    this.minCheck = null;
    this.maxCheck = null;
    this.trimEnabled = false;
    this.uuidCheck = null;
    this.urlCheck = null;
  }

  trim() {
    this.trimEnabled = true;
    return this;
  }

  min(value, params = {}) {
    this.minCheck = { value, message: params.message };
    return this;
  }

  max(value, params = {}) {
    this.maxCheck = { value, message: params.message };
    return this;
  }

  uuid(params = {}) {
    this.uuidCheck = { message: params.message || 'Invalid uuid' };
    return this;
  }

  url(params = {}) {
    this.urlCheck = { message: params.message || 'Invalid url' };
    return this;
  }

  parse(value, path = []) {
    if (value === undefined) {
      const message = this.options.required_error || 'Required';
      throw new ZodError([{ path, message, code: ZodIssueCode.custom }]);
    }
    if (typeof value !== 'string') {
      const message = this.options.invalid_type_error || 'Expected string';
      throw new ZodError([{ path, message, code: ZodIssueCode.invalid_type }]);
    }
    let result = value;
    if (this.trimEnabled) {
      result = result.trim();
    }
    if (this.minCheck && result.length < this.minCheck.value) {
      const message = this.minCheck.message || `String must contain at least ${this.minCheck.value} character(s)`;
      throw new ZodError([{ path, message, code: ZodIssueCode.custom }]);
    }
    if (this.maxCheck && result.length > this.maxCheck.value) {
      const message = this.maxCheck.message || `String must contain at most ${this.maxCheck.value} character(s)`;
      throw new ZodError([{ path, message, code: ZodIssueCode.custom }]);
    }
    if (this.uuidCheck && !uuidRegex.test(result)) {
      throw new ZodError([{ path, message: this.uuidCheck.message, code: ZodIssueCode.custom }]);
    }
    if (this.urlCheck) {
      try {
        const parsed = new URL(result);
        if (!parsed.protocol || !parsed.host) {
          throw new Error();
        }
      } catch (error) {
        throw new ZodError([{ path, message: this.urlCheck.message, code: ZodIssueCode.custom }]);
      }
    }
    return result;
  }
}

class NumberSchema extends BaseSchema {
  constructor(options = {}) {
    super();
    this.options = options;
    this.minCheck = null;
    this.maxCheck = null;
    this.intCheck = false;
    this.positiveCheck = null;
    this.gteCheck = null;
    this.lteCheck = null;
  }

  min(value, params = {}) {
    this.minCheck = { value, message: params.message };
    return this;
  }

  max(value, params = {}) {
    this.maxCheck = { value, message: params.message };
    return this;
  }

  int(params = {}) {
    this.intCheck = { message: params.message || 'Expected integer' };
    return this;
  }

  positive(params = {}) {
    this.positiveCheck = { message: params.message || 'Expected positive number' };
    return this;
  }

  gte(value, params = {}) {
    this.gteCheck = { value, message: params.message };
    return this;
  }

  lte(value, params = {}) {
    this.lteCheck = { value, message: params.message };
    return this;
  }

  parse(value, path = []) {
    if (value === undefined) {
      const message = this.options.required_error || 'Required';
      throw new ZodError([{ path, message, code: ZodIssueCode.custom }]);
    }
    if (typeof value !== 'number' || Number.isNaN(value)) {
      const message = this.options.invalid_type_error || 'Expected number';
      throw new ZodError([{ path, message, code: ZodIssueCode.invalid_type }]);
    }
    if (this.minCheck && value < this.minCheck.value) {
      const message = this.minCheck.message || `Number must be greater than or equal to ${this.minCheck.value}`;
      throw new ZodError([{ path, message, code: ZodIssueCode.custom }]);
    }
    if (this.maxCheck && value > this.maxCheck.value) {
      const message = this.maxCheck.message || `Number must be less than or equal to ${this.maxCheck.value}`;
      throw new ZodError([{ path, message, code: ZodIssueCode.custom }]);
    }
    if (this.gteCheck && value < this.gteCheck.value) {
      const message = this.gteCheck.message || `Number must be greater than or equal to ${this.gteCheck.value}`;
      throw new ZodError([{ path, message, code: ZodIssueCode.custom }]);
    }
    if (this.lteCheck && value > this.lteCheck.value) {
      const message = this.lteCheck.message || `Number must be less than or equal to ${this.lteCheck.value}`;
      throw new ZodError([{ path, message, code: ZodIssueCode.custom }]);
    }
    if (this.positiveCheck && value <= 0) {
      throw new ZodError([{ path, message: this.positiveCheck.message, code: ZodIssueCode.custom }]);
    }
    if (this.intCheck && !Number.isInteger(value)) {
      throw new ZodError([{ path, message: this.intCheck.message, code: ZodIssueCode.custom }]);
    }
    return value;
  }
}

class ArraySchema extends BaseSchema {
  constructor(elementSchema) {
    super();
    this.elementSchema = elementSchema;
    this.maxCheck = null;
  }

  max(value, params = {}) {
    this.maxCheck = { value, message: params.message };
    return this;
  }

  parse(value, path = []) {
    if (!Array.isArray(value)) {
      throw new ZodError([{ path, message: 'Expected array', code: ZodIssueCode.invalid_type }]);
    }
    if (this.maxCheck && value.length > this.maxCheck.value) {
      const message = this.maxCheck.message || `Array must contain at most ${this.maxCheck.value} item(s)`;
      throw new ZodError([{ path, message, code: ZodIssueCode.custom }]);
    }
    return value.map((item, index) => this.elementSchema.parse(item, [...path, index]));
  }
}

class ObjectSchema extends BaseSchema {
  constructor(shape) {
    super();
    this.shape = shape;
    this.strictMode = false;
  }

  strict() {
    this.strictMode = true;
    return this;
  }

  parse(value, path = []) {
    if (value === undefined || value === null || typeof value !== 'object' || Array.isArray(value)) {
      throw new ZodError([{ path, message: 'Expected object', code: ZodIssueCode.invalid_type }]);
    }

    if (this.strictMode) {
      const unknownKeys = Object.keys(value).filter((key) => !(key in this.shape));
      if (unknownKeys.length) {
        throw new ZodError([
          {
            path,
            message: `Unrecognized key(s): ${unknownKeys.join(', ')}`,
            code: ZodIssueCode.custom,
          },
        ]);
      }
    }

    const result = {};
    for (const key of Object.keys(this.shape)) {
      const schema = this.shape[key];
      const parsed = schema.parse(value[key], [...path, key]);
      result[key] = parsed;
    }
    return result;
  }
}

class DateSchema extends BaseSchema {
  constructor(options = {}) {
    super();
    this.options = options;
  }

  parse(value, path = []) {
    if (value === undefined) {
      const message = this.options.required_error || 'Required';
      throw new ZodError([{ path, message, code: ZodIssueCode.custom }]);
    }
    if (!(value instanceof Date) || Number.isNaN(value.getTime())) {
      const message = this.options.invalid_type_error || 'Expected date';
      throw new ZodError([{ path, message, code: ZodIssueCode.invalid_type }]);
    }
    return value;
  }
}

function literal(value) {
  return new LiteralSchema(value);
}

function enumeration(values, options = {}) {
  return new EnumSchema(values, options);
}

function union(schemas) {
  return new UnionSchema(schemas);
}

function preprocess(preprocessor, schema) {
  return new PreprocessSchema(preprocessor, schema);
}

function any() {
  return new AnySchema();
}

function string(options = {}) {
  return new StringSchema(options);
}

function number(options = {}) {
  return new NumberSchema(options);
}

function array(schema) {
  return new ArraySchema(schema);
}

function object(shape) {
  return new ObjectSchema(shape);
}

function date(options = {}) {
  return new DateSchema(options);
}

module.exports = {
  z: {
    string,
    number,
    array,
    object,
    union,
    literal,
    enum: enumeration,
    preprocess,
    any,
    date,
  },
  ZodError,
  ZodIssueCode,
};
